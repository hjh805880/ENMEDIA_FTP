{
  "resolvedId": "/Users/hanjeonghun/Documents/GitHub/이엔미디어_홈페이지FTP/node_modules/@unhead/schema-org/dist/shared/schema-org.2bb4d7a1.mjs",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { hashCode, defineHeadPlugin, processTemplateParams } from '@unhead/shared';\nimport { hasProtocol, withBase, withoutTrailingSlash, hasTrailingSlash, withTrailingSlash, joinURL } from 'ufo';\n\nfunction defineSchemaOrgResolver(schema) {\n  return schema;\n}\n\nfunction idReference(node) {\n  return {\n    \"@id\": typeof node !== \"string\" ? node[\"@id\"] : node\n  };\n}\nfunction resolvableDateToDate(val) {\n  try {\n    const date = val instanceof Date ? val : new Date(Date.parse(val));\n    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;\n  } catch (e) {\n  }\n  return typeof val === \"string\" ? val : val.toString();\n}\nconst IS_VALID_W3C_DATE = [\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/,\n  /^\\d{4}-[01]\\d-[0-3]\\d$/,\n  /^\\d{4}-[01]\\d$/,\n  /^\\d{4}$/\n];\nfunction isValidW3CDate(d) {\n  return IS_VALID_W3C_DATE.some((r) => r.test(d));\n}\nfunction resolvableDateToIso(val) {\n  if (!val)\n    return val;\n  try {\n    if (val instanceof Date)\n      return val.toISOString();\n    else if (isValidW3CDate(val))\n      return val;\n    else\n      return new Date(Date.parse(val)).toISOString();\n  } catch (e) {\n  }\n  return typeof val === \"string\" ? val : val.toString();\n}\nconst IdentityId = \"#identity\";\nfunction setIfEmpty(node, field, value) {\n  if (!node?.[field] && value)\n    node[field] = value;\n}\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nfunction dedupeMerge(node, field, value) {\n  const dedupeMerge2 = [];\n  const input = asArray(node[field]);\n  dedupeMerge2.push(...input);\n  const data = new Set(dedupeMerge2);\n  data.add(value);\n  node[field] = [...data.values()].filter(Boolean);\n}\nfunction prefixId(url, id) {\n  if (hasProtocol(id))\n    return id;\n  if (!id.startsWith(\"#\"))\n    id = `#${id}`;\n  return withBase(id, url);\n}\nfunction trimLength(val, length) {\n  if (!val)\n    return val;\n  if (val.length > length) {\n    const trimmedString = val.substring(0, length);\n    return trimmedString.substring(0, Math.min(trimmedString.length, trimmedString.lastIndexOf(\" \")));\n  }\n  return val;\n}\nfunction resolveDefaultType(node, defaultType) {\n  const val = node[\"@type\"];\n  if (val === defaultType)\n    return;\n  const types = /* @__PURE__ */ new Set([\n    ...asArray(defaultType),\n    ...asArray(val)\n  ]);\n  node[\"@type\"] = types.size === 1 ? val : [...types.values()];\n}\nfunction resolveWithBase(base, urlOrPath) {\n  if (!urlOrPath || hasProtocol(urlOrPath) || !urlOrPath.startsWith(\"/\") && !urlOrPath.startsWith(\"#\"))\n    return urlOrPath;\n  return withBase(urlOrPath, base);\n}\nfunction resolveAsGraphKey(key) {\n  if (!key)\n    return key;\n  return key.substring(key.lastIndexOf(\"#\"));\n}\nfunction stripEmptyProperties(obj) {\n  Object.keys(obj).forEach((k) => {\n    if (obj[k] && typeof obj[k] === \"object\") {\n      if (obj[k].__v_isReadonly || obj[k].__v_isRef)\n        return;\n      stripEmptyProperties(obj[k]);\n      return;\n    }\n    if (obj[k] === \"\" || obj[k] === null || typeof obj[k] === \"undefined\")\n      delete obj[k];\n  });\n  return obj;\n}\n\nconst offerResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"number\" || typeof node === \"string\") {\n      return {\n        price: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Offer\",\n    \"availability\": \"InStock\"\n  },\n  resolve(node, ctx) {\n    setIfEmpty(node, \"priceCurrency\", ctx.meta.currency);\n    setIfEmpty(node, \"priceValidUntil\", new Date(Date.UTC((/* @__PURE__ */ new Date()).getFullYear() + 1, 12, -1, 0, 0, 0)));\n    if (node.url)\n      resolveWithBase(ctx.meta.host, node.url);\n    if (node.availability)\n      node.availability = withBase(node.availability, \"https://schema.org/\");\n    if (node.priceValidUntil)\n      node.priceValidUntil = resolvableDateToIso(node.priceValidUntil);\n    return node;\n  }\n});\n\nconst aggregateOfferResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"AggregateOffer\"\n  },\n  inheritMeta: [\n    { meta: \"currency\", key: \"priceCurrency\" }\n  ],\n  resolve(node, ctx) {\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    if (node.offers)\n      setIfEmpty(node, \"offerCount\", asArray(node.offers).length);\n    return node;\n  }\n});\n\nconst aggregateRatingResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"AggregateRating\"\n  }\n});\n\nconst searchActionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"SearchAction\",\n    \"target\": {\n      \"@type\": \"EntryPoint\"\n    },\n    \"query-input\": {\n      \"@type\": \"PropertyValueSpecification\",\n      \"valueRequired\": true,\n      \"valueName\": \"search_term_string\"\n    }\n  },\n  resolve(node, ctx) {\n    if (typeof node.target === \"string\") {\n      node.target = {\n        \"@type\": \"EntryPoint\",\n        \"urlTemplate\": resolveWithBase(ctx.meta.host, node.target)\n      };\n    }\n    return node;\n  }\n});\n\nconst PrimaryWebSiteId = \"#website\";\nconst webSiteResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"WebSite\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    { meta: \"host\", key: \"url\" }\n  ],\n  idPrefix: [\"host\", PrimaryWebSiteId],\n  resolve(node, ctx) {\n    node.potentialAction = resolveRelation(node.potentialAction, ctx, searchActionResolver, {\n      array: true\n    });\n    node.publisher = resolveRelation(node.publisher, ctx);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    if (resolveAsGraphKey(node[\"@id\"]) === PrimaryWebSiteId) {\n      const identity = find(IdentityId);\n      if (identity)\n        setIfEmpty(node, \"publisher\", idReference(identity));\n      const webPage = find(PrimaryWebPageId);\n      if (webPage)\n        setIfEmpty(webPage, \"isPartOf\", idReference(node));\n    }\n    return node;\n  }\n});\n\nconst listItemResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      node = {\n        name: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"ListItem\"\n  },\n  resolve(node, ctx) {\n    if (typeof node.item === \"string\")\n      node.item = resolveWithBase(ctx.meta.host, node.item);\n    else if (typeof node.item === \"object\")\n      node.item = resolveRelation(node.item, ctx);\n    return node;\n  }\n});\n\nconst PrimaryBreadcrumbId = \"#breadcrumb\";\nconst breadcrumbResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"BreadcrumbList\"\n  },\n  idPrefix: [\"url\", PrimaryBreadcrumbId],\n  resolve(breadcrumb, ctx) {\n    if (breadcrumb.itemListElement) {\n      let index = 1;\n      breadcrumb.itemListElement = resolveRelation(breadcrumb.itemListElement, ctx, listItemResolver, {\n        array: true,\n        afterResolve(node) {\n          setIfEmpty(node, \"position\", index++);\n        }\n      });\n    }\n    return breadcrumb;\n  },\n  resolveRootNode(node, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage)\n      setIfEmpty(webPage, \"breadcrumb\", idReference(node));\n  }\n});\n\nconst imageResolver = defineSchemaOrgResolver({\n  alias: \"image\",\n  cast(input) {\n    if (typeof input === \"string\") {\n      input = {\n        url: input\n      };\n    }\n    return input;\n  },\n  defaults: {\n    \"@type\": \"ImageObject\"\n  },\n  inheritMeta: [\n    // @todo possibly only do if there's a caption\n    \"inLanguage\"\n  ],\n  idPrefix: \"host\",\n  resolve(image, { meta }) {\n    image.url = resolveWithBase(meta.host, image.url);\n    setIfEmpty(image, \"contentUrl\", image.url);\n    if (image.height && !image.width)\n      delete image.height;\n    if (image.width && !image.height)\n      delete image.width;\n    return image;\n  }\n});\n\nconst addressResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"PostalAddress\"\n  }\n});\n\nconst organizationResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Organization\"\n  },\n  idPrefix: [\"host\", IdentityId],\n  inheritMeta: [\n    { meta: \"host\", key: \"url\" }\n  ],\n  resolve(node, ctx) {\n    resolveDefaultType(node, \"Organization\");\n    node.address = resolveRelation(node.address, ctx, addressResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    const isIdentity = resolveAsGraphKey(node[\"@id\"]) === IdentityId;\n    const webPage = ctx.find(PrimaryWebPageId);\n    if (node.logo && isIdentity) {\n      if (!ctx.find(\"#organization\")) {\n        const logoNode = resolveRelation(node.logo, ctx, imageResolver, {\n          root: true,\n          afterResolve(logo) {\n            logo[\"@id\"] = prefixId(ctx.meta.host, \"#logo\");\n            setIfEmpty(logo, \"caption\", node.name);\n          }\n        });\n        if (webPage && logoNode)\n          setIfEmpty(webPage, \"primaryImageOfPage\", idReference(logoNode));\n        ctx.nodes.push({\n          // we want to make a simple node that has the essentials, this will allow parent nodes to inject\n          // as well without inserting invalid data (i.e LocalBusiness operatingHours)\n          \"@type\": \"Organization\",\n          \"name\": node.name,\n          \"url\": node.url,\n          \"sameAs\": node.sameAs,\n          // 'image': idReference(logoNode),\n          \"address\": node.address,\n          // needs to be a URL\n          \"logo\": resolveRelation(node.logo, ctx, imageResolver, { root: false }).url,\n          \"_priority\": -1,\n          \"@id\": prefixId(ctx.meta.host, \"#organization\")\n          // avoid the id so nothing can link to it\n        });\n      }\n      delete node.logo;\n    }\n    if (isIdentity && webPage)\n      setIfEmpty(webPage, \"about\", idReference(node));\n    const webSite = ctx.find(PrimaryWebSiteId);\n    if (webSite)\n      setIfEmpty(webSite, \"publisher\", idReference(node));\n  }\n});\n\nconst personResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        name: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Person\"\n  },\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    if (node.url)\n      node.url = resolveWithBase(ctx.meta.host, node.url);\n    return node;\n  },\n  resolveRootNode(node, { find, meta }) {\n    if (resolveAsGraphKey(node[\"@id\"]) === IdentityId) {\n      setIfEmpty(node, \"url\", meta.host);\n      const webPage = find(PrimaryWebPageId);\n      if (webPage)\n        setIfEmpty(webPage, \"about\", idReference(node));\n      const webSite = find(PrimaryWebSiteId);\n      if (webSite)\n        setIfEmpty(webSite, \"publisher\", idReference(node));\n    }\n    const article = find(PrimaryArticleId);\n    if (article)\n      setIfEmpty(article, \"author\", idReference(node));\n  }\n});\n\nconst readActionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"ReadAction\"\n  },\n  resolve(node, ctx) {\n    if (!node.target.includes(ctx.meta.url))\n      node.target.unshift(ctx.meta.url);\n    return node;\n  }\n});\n\nconst PrimaryWebPageId = \"#webpage\";\nconst webPageResolver = defineSchemaOrgResolver({\n  defaults({ meta }) {\n    const endPath = withoutTrailingSlash(meta.url.substring(meta.url.lastIndexOf(\"/\") + 1));\n    let type = \"WebPage\";\n    switch (endPath) {\n      case \"about\":\n      case \"about-us\":\n        type = \"AboutPage\";\n        break;\n      case \"search\":\n        type = \"SearchResultsPage\";\n        break;\n      case \"checkout\":\n        type = \"CheckoutPage\";\n        break;\n      case \"contact\":\n      case \"get-in-touch\":\n      case \"contact-us\":\n        type = \"ContactPage\";\n        break;\n      case \"faq\":\n        type = \"FAQPage\";\n        break;\n    }\n    const defaults = {\n      \"@type\": type\n    };\n    return defaults;\n  },\n  idPrefix: [\"url\", PrimaryWebPageId],\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"datePublished\",\n    \"dateModified\",\n    \"url\"\n  ],\n  resolve(node, ctx) {\n    node.dateModified = resolvableDateToIso(node.dateModified);\n    node.datePublished = resolvableDateToIso(node.datePublished);\n    resolveDefaultType(node, \"WebPage\");\n    node.about = resolveRelation(node.about, ctx, organizationResolver);\n    node.breadcrumb = resolveRelation(node.breadcrumb, ctx, breadcrumbResolver);\n    node.author = resolveRelation(node.author, ctx, personResolver);\n    node.primaryImageOfPage = resolveRelation(node.primaryImageOfPage, ctx, imageResolver);\n    node.potentialAction = resolveRelation(node.potentialAction, ctx, readActionResolver);\n    if (node[\"@type\"] === \"WebPage\" && ctx.meta.url) {\n      setIfEmpty(node, \"potentialAction\", [\n        {\n          \"@type\": \"ReadAction\",\n          \"target\": [ctx.meta.url]\n        }\n      ]);\n    }\n    return node;\n  },\n  resolveRootNode(webPage, { find, meta }) {\n    const identity = find(IdentityId);\n    const webSite = find(PrimaryWebSiteId);\n    const logo = find(\"#logo\");\n    if (identity && meta.url === meta.host)\n      setIfEmpty(webPage, \"about\", idReference(identity));\n    if (logo)\n      setIfEmpty(webPage, \"primaryImageOfPage\", idReference(logo));\n    if (webSite)\n      setIfEmpty(webPage, \"isPartOf\", idReference(webSite));\n    const breadcrumb = find(PrimaryBreadcrumbId);\n    if (breadcrumb)\n      setIfEmpty(webPage, \"breadcrumb\", idReference(breadcrumb));\n    return webPage;\n  }\n});\n\nconst PrimaryArticleId = \"#article\";\nconst articleResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Article\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    \"description\",\n    \"image\",\n    \"dateModified\",\n    \"datePublished\",\n    { meta: \"title\", key: \"headline\" }\n  ],\n  idPrefix: [\"url\", PrimaryArticleId],\n  resolve(node, ctx) {\n    node.author = resolveRelation(node.author, ctx, personResolver, {\n      root: true\n    });\n    node.publisher = resolveRelation(node.publisher, ctx);\n    node.dateModified = resolvableDateToIso(node.dateModified);\n    node.datePublished = resolvableDateToIso(node.datePublished);\n    resolveDefaultType(node, \"Article\");\n    node.headline = trimLength(node.headline, 110);\n    return node;\n  },\n  resolveRootNode(node, { find, meta }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (node.image && !node.thumbnailUrl) {\n      const firstImage = asArray(node.image)[0];\n      if (typeof firstImage === \"string\")\n        setIfEmpty(node, \"thumbnailUrl\", resolveWithBase(meta.host, firstImage));\n      else if (firstImage?.[\"@id\"])\n        setIfEmpty(node, \"thumbnailUrl\", find(firstImage[\"@id\"])?.url);\n    }\n    if (identity) {\n      setIfEmpty(node, \"publisher\", idReference(identity));\n      setIfEmpty(node, \"author\", idReference(identity));\n    }\n    if (webPage) {\n      setIfEmpty(node, \"isPartOf\", idReference(webPage));\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n      setIfEmpty(webPage, \"potentialAction\", [\n        {\n          \"@type\": \"ReadAction\",\n          \"target\": [meta.url]\n        }\n      ]);\n      setIfEmpty(webPage, \"dateModified\", node.dateModified);\n      setIfEmpty(webPage, \"datePublished\", node.datePublished);\n    }\n    return node;\n  }\n});\n\nconst bookEditionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Book\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  resolve(node, ctx) {\n    if (node.bookFormat)\n      node.bookFormat = withBase(node.bookFormat, \"https://schema.org/\");\n    if (node.datePublished)\n      node.datePublished = resolvableDateToDate(node.datePublished);\n    node.author = resolveRelation(node.author, ctx);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"provider\", idReference(identity));\n    return node;\n  }\n});\nconst PrimaryBookId = \"#book\";\nconst bookResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Book\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"url\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", PrimaryBookId],\n  resolve(node, ctx) {\n    node.workExample = resolveRelation(node.workExample, ctx, bookEditionResolver);\n    node.author = resolveRelation(node.author, ctx);\n    if (node.url)\n      withBase(node.url, ctx.meta.host);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"author\", idReference(identity));\n    return node;\n  }\n});\n\nconst commentResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Comment\"\n  },\n  idPrefix: \"url\",\n  resolve(node, ctx) {\n    node.author = resolveRelation(node.author, ctx, personResolver, {\n      root: true\n    });\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const article = find(PrimaryArticleId);\n    if (article)\n      setIfEmpty(node, \"about\", idReference(article));\n  }\n});\n\nconst courseResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Course\"\n  },\n  resolve(node, ctx) {\n    node.provider = resolveRelation(node.provider, ctx, organizationResolver, {\n      root: true\n    });\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"provider\", idReference(identity));\n    return node;\n  }\n});\n\nconst placeResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Place\"\n  },\n  resolve(node, ctx) {\n    if (typeof node.address !== \"string\")\n      node.address = resolveRelation(node.address, ctx, addressResolver);\n    return node;\n  }\n});\n\nconst virtualLocationResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        url: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"VirtualLocation\"\n  }\n});\n\nconst PrimaryEventId = \"#event\";\nconst eventResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Event\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    \"description\",\n    \"image\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", PrimaryEventId],\n  resolve(node, ctx) {\n    if (node.location) {\n      const isVirtual = node.location === \"string\" || node.location?.url !== \"undefined\";\n      node.location = resolveRelation(node.location, ctx, isVirtual ? virtualLocationResolver : placeResolver);\n    }\n    node.performer = resolveRelation(node.performer, ctx, personResolver, {\n      root: true\n    });\n    node.organizer = resolveRelation(node.organizer, ctx, organizationResolver, {\n      root: true\n    });\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    if (node.eventAttendanceMode)\n      node.eventAttendanceMode = withBase(node.eventAttendanceMode, \"https://schema.org/\");\n    if (node.eventStatus)\n      node.eventStatus = withBase(node.eventStatus, \"https://schema.org/\");\n    const isOnline = node.eventStatus === \"https://schema.org/EventMovedOnline\";\n    const dates = [\"startDate\", \"previousStartDate\", \"endDate\"];\n    dates.forEach((date) => {\n      if (!isOnline) {\n        if (node[date] instanceof Date && node[date].getHours() === 0 && node[date].getMinutes() === 0)\n          node[date] = resolvableDateToDate(node[date]);\n      } else {\n        node[date] = resolvableDateToIso(node[date]);\n      }\n    });\n    setIfEmpty(node, \"endDate\", node.startDate);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"organizer\", idReference(identity));\n  }\n});\n\nconst ratingResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (node === \"number\") {\n      return {\n        ratingValue: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Rating\",\n    \"bestRating\": 5,\n    \"worstRating\": 1\n  }\n});\n\nconst openingHoursResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"OpeningHoursSpecification\",\n    \"opens\": \"00:00\",\n    \"closes\": \"23:59\"\n  }\n});\n\nconst localBusinessResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": [\"Organization\", \"LocalBusiness\"]\n  },\n  inheritMeta: [\n    { key: \"url\", meta: \"host\" },\n    { key: \"currenciesAccepted\", meta: \"currency\" }\n  ],\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    resolveDefaultType(node, [\"Organization\", \"LocalBusiness\"]);\n    node.address = resolveRelation(node.address, ctx, addressResolver);\n    node.openingHoursSpecification = resolveRelation(node.openingHoursSpecification, ctx, openingHoursResolver);\n    node = resolveNode({ ...node }, ctx, organizationResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    organizationResolver.resolveRootNode(node, ctx);\n    return node;\n  }\n});\n\nconst foodEstablishmentResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": [\"Organization\", \"LocalBusiness\", \"FoodEstablishment\"]\n  },\n  inheritMeta: [\n    { key: \"url\", meta: \"host\" },\n    { key: \"currenciesAccepted\", meta: \"currency\" }\n  ],\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    resolveDefaultType(node, [\"Organization\", \"LocalBusiness\", \"FoodEstablishment\"]);\n    node.starRating = resolveRelation(node.starRating, ctx, ratingResolver);\n    node = resolveNode(node, ctx, localBusinessResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    localBusinessResolver.resolveRootNode(node, ctx);\n    return node;\n  }\n});\n\nconst howToStepDirectionResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"HowToDirection\"\n  }\n});\n\nconst howToStepResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"HowToStep\"\n  },\n  resolve(step, ctx) {\n    if (step.url)\n      step.url = resolveWithBase(ctx.meta.url, step.url);\n    if (step.image) {\n      step.image = resolveRelation(step.image, ctx, imageResolver, {\n        root: true\n      });\n    }\n    if (step.itemListElement)\n      step.itemListElement = resolveRelation(step.itemListElement, ctx, howToStepDirectionResolver);\n    return step;\n  }\n});\n\nconst HowToId = \"#howto\";\nconst howToResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"HowTo\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"image\",\n    \"inLanguage\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", HowToId],\n  resolve(node, ctx) {\n    node.step = resolveRelation(node.step, ctx, howToStepResolver);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n  }\n});\n\nconst itemListResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"ItemList\"\n  },\n  resolve(node, ctx) {\n    if (node.itemListElement) {\n      let index = 1;\n      node.itemListElement = resolveRelation(node.itemListElement, ctx, listItemResolver, {\n        array: true,\n        afterResolve(node2) {\n          setIfEmpty(node2, \"position\", index++);\n        }\n      });\n    }\n    return node;\n  }\n});\n\nconst quantitativeValueResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"QuantitativeValue\"\n  }\n});\nconst monetaryAmountResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"MonetaryAmount\"\n  },\n  resolve(node, ctx) {\n    node.value = resolveRelation(node.value, ctx, quantitativeValueResolver);\n    return node;\n  }\n});\n\nconst jobPostingResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"JobPosting\"\n  },\n  idPrefix: [\"url\", \"#job-posting\"],\n  resolve(node, ctx) {\n    node.datePosted = resolvableDateToIso(node.datePosted);\n    node.hiringOrganization = resolveRelation(node.hiringOrganization, ctx, organizationResolver);\n    node.jobLocation = resolveRelation(node.jobLocation, ctx, placeResolver);\n    node.baseSalary = resolveRelation(node.baseSalary, ctx, monetaryAmountResolver);\n    node.validThrough = resolvableDateToIso(node.validThrough);\n    return node;\n  },\n  resolveRootNode(jobPosting, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(jobPosting, \"hiringOrganization\", idReference(identity));\n    if (webPage)\n      setIfEmpty(jobPosting, \"mainEntityOfPage\", idReference(webPage));\n    return jobPosting;\n  }\n});\n\nconst reviewResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Review\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  resolve(review, ctx) {\n    review.reviewRating = resolveRelation(review.reviewRating, ctx, ratingResolver);\n    review.author = resolveRelation(review.author, ctx, personResolver);\n    return review;\n  }\n});\n\nconst videoResolver = defineSchemaOrgResolver({\n  cast(input) {\n    if (typeof input === \"string\") {\n      input = {\n        url: input\n      };\n    }\n    return input;\n  },\n  alias: \"video\",\n  defaults: {\n    \"@type\": \"VideoObject\"\n  },\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"image\",\n    \"inLanguage\",\n    { meta: \"datePublished\", key: \"uploadDate\" }\n  ],\n  idPrefix: \"host\",\n  resolve(video, ctx) {\n    if (video.uploadDate)\n      video.uploadDate = resolvableDateToIso(video.uploadDate);\n    video.url = resolveWithBase(ctx.meta.host, video.url);\n    if (video.caption && !video.description)\n      video.description = video.caption;\n    if (!video.description)\n      video.description = \"No description\";\n    if (video.thumbnailUrl)\n      video.thumbnailUrl = resolveRelation(video.thumbnailUrl, ctx, imageResolver);\n    return video;\n  },\n  resolveRootNode(video, { find }) {\n    if (video.image && !video.thumbnailUrl) {\n      const firstImage = asArray(video.image)[0];\n      setIfEmpty(video, \"thumbnailUrl\", find(firstImage[\"@id\"])?.url);\n    }\n  }\n});\n\nconst movieResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Movie\"\n  },\n  resolve(node, ctx) {\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    node.director = resolveRelation(node.director, ctx, personResolver);\n    node.actor = resolveRelation(node.actor, ctx, personResolver);\n    node.trailer = resolveRelation(node.trailer, ctx, videoResolver);\n    if (node.dateCreated)\n      node.dateCreated = resolvableDateToDate(node.dateCreated);\n    return node;\n  }\n});\n\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\n\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\n\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\n\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\n\nconst ProductId = \"#product\";\nconst productResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Product\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"image\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", ProductId],\n  resolve(node, ctx) {\n    setIfEmpty(node, \"sku\", hash(node.name));\n    node.aggregateOffer = resolveRelation(node.aggregateOffer, ctx, aggregateOfferResolver);\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    return node;\n  },\n  resolveRootNode(product, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(product, \"brand\", idReference(identity));\n    if (webPage)\n      setIfEmpty(product, \"mainEntityOfPage\", idReference(webPage));\n    return product;\n  }\n});\n\nconst answerResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Answer\"\n  }\n});\n\nconst questionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Question\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  idPrefix: \"url\",\n  resolve(question, ctx) {\n    if (question.question) {\n      question.name = question.question;\n      delete question.question;\n    }\n    if (question.answer) {\n      question.acceptedAnswer = question.answer;\n      delete question.answer;\n    }\n    question.acceptedAnswer = resolveRelation(question.acceptedAnswer, ctx, answerResolver);\n    return question;\n  },\n  resolveRootNode(question, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage && asArray(webPage[\"@type\"]).includes(\"FAQPage\"))\n      dedupeMerge(webPage, \"mainEntity\", idReference(question));\n  }\n});\n\nconst RecipeId = \"#recipe\";\nconst recipeResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Recipe\"\n  },\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"image\",\n    \"datePublished\"\n  ],\n  idPrefix: [\"url\", RecipeId],\n  resolve(node, ctx) {\n    node.recipeInstructions = resolveRelation(node.recipeInstructions, ctx, howToStepResolver);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const article = find(PrimaryArticleId);\n    const webPage = find(PrimaryWebPageId);\n    if (article)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(article));\n    else if (webPage)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n    if (article?.author)\n      setIfEmpty(node, \"author\", article.author);\n    return node;\n  }\n});\n\nconst softwareAppResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"SoftwareApplication\"\n  },\n  resolve(node, ctx) {\n    resolveDefaultType(node, \"SoftwareApplication\");\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    return node;\n  }\n});\n\nfunction loadResolver(resolver) {\n  switch (resolver) {\n    case \"address\":\n      return addressResolver;\n    case \"aggregateOffer\":\n      return aggregateOfferResolver;\n    case \"aggregateRating\":\n      return aggregateRatingResolver;\n    case \"article\":\n      return articleResolver;\n    case \"breadcrumb\":\n      return breadcrumbResolver;\n    case \"comment\":\n      return commentResolver;\n    case \"event\":\n      return eventResolver;\n    case \"foodEstablishment\":\n      return foodEstablishmentResolver;\n    case \"virtualLocation\":\n      return virtualLocationResolver;\n    case \"place\":\n      return placeResolver;\n    case \"howTo\":\n      return howToResolver;\n    case \"howToStep\":\n      return howToStepResolver;\n    case \"image\":\n      return imageResolver;\n    case \"localBusiness\":\n      return localBusinessResolver;\n    case \"offer\":\n      return offerResolver;\n    case \"openingHours\":\n      return openingHoursResolver;\n    case \"organization\":\n      return organizationResolver;\n    case \"person\":\n      return personResolver;\n    case \"product\":\n      return productResolver;\n    case \"question\":\n      return questionResolver;\n    case \"recipe\":\n      return recipeResolver;\n    case \"review\":\n      return reviewResolver;\n    case \"video\":\n      return videoResolver;\n    case \"webPage\":\n      return webPageResolver;\n    case \"webSite\":\n      return webSiteResolver;\n    case \"book\":\n      return bookResolver;\n    case \"course\":\n      return courseResolver;\n    case \"itemList\":\n      return itemListResolver;\n    case \"jobPosting\":\n      return jobPostingResolver;\n    case \"listItem\":\n      return listItemResolver;\n    case \"movie\":\n      return movieResolver;\n    case \"searchAction\":\n      return searchActionResolver;\n    case \"readAction\":\n      return readActionResolver;\n    case \"softwareApp\":\n      return softwareAppResolver;\n    case \"bookEdition\":\n      return bookEditionResolver;\n  }\n  return null;\n}\n\nconst resolver = {\n  __proto__: null,\n  loadResolver: loadResolver\n};\n\nfunction resolveMeta(meta) {\n  if (!meta.host && meta.canonicalHost)\n    meta.host = meta.canonicalHost;\n  if (!meta.tagPosition && meta.position)\n    meta.tagPosition = meta.position;\n  if (!meta.currency && meta.defaultCurrency)\n    meta.currency = meta.defaultCurrency;\n  if (!meta.inLanguage && meta.defaultLanguage)\n    meta.inLanguage = meta.defaultLanguage;\n  if (!meta.path)\n    meta.path = \"/\";\n  if (!meta.host && typeof document !== \"undefined\")\n    meta.host = document.location.host;\n  if (!meta.url && meta.canonicalUrl)\n    meta.url = meta.canonicalUrl;\n  if (meta.path !== \"/\") {\n    if (meta.trailingSlash && !hasTrailingSlash(meta.path))\n      meta.path = withTrailingSlash(meta.path);\n    else if (!meta.trailingSlash && hasTrailingSlash(meta.path))\n      meta.path = withoutTrailingSlash(meta.path);\n  }\n  meta.url = joinURL(meta.host || \"\", meta.path);\n  return {\n    ...meta,\n    host: meta.host,\n    url: meta.url,\n    currency: meta.currency,\n    image: meta.image,\n    inLanguage: meta.inLanguage,\n    title: meta.title,\n    description: meta.description,\n    datePublished: meta.datePublished,\n    dateModified: meta.dateModified\n  };\n}\nfunction resolveNode(node, ctx, resolver) {\n  if (resolver?.cast)\n    node = resolver.cast(node, ctx);\n  if (resolver?.defaults) {\n    let defaults = resolver.defaults || {};\n    if (typeof defaults === \"function\")\n      defaults = defaults(ctx);\n    node = {\n      ...defaults,\n      ...node\n    };\n  }\n  resolver.inheritMeta?.forEach((entry) => {\n    if (typeof entry === \"string\")\n      setIfEmpty(node, entry, ctx.meta[entry]);\n    else\n      setIfEmpty(node, entry.key, ctx.meta[entry.meta]);\n  });\n  if (resolver?.resolve)\n    node = resolver.resolve(node, ctx);\n  for (const k in node) {\n    const v = node[k];\n    if (typeof v === \"object\" && v?._resolver)\n      node[k] = resolveRelation(v, ctx, v._resolver);\n  }\n  stripEmptyProperties(node);\n  return node;\n}\nfunction resolveNodeId(node, ctx, resolver, resolveAsRoot = false) {\n  if (node[\"@id\"] && node[\"@id\"].startsWith(\"http\"))\n    return node;\n  const prefix = (Array.isArray(resolver.idPrefix) ? resolver.idPrefix[0] : resolver.idPrefix) || \"url\";\n  const rootId = node[\"@id\"] || (Array.isArray(resolver.idPrefix) ? resolver.idPrefix?.[1] : void 0);\n  if (!node[\"@id\"] && resolveAsRoot && rootId) {\n    node[\"@id\"] = prefixId(ctx.meta[prefix], rootId);\n    return node;\n  }\n  if (node[\"@id\"]?.startsWith(\"#/schema/\")) {\n    node[\"@id\"] = prefixId(ctx.meta[prefix], node[\"@id\"]);\n    return node;\n  }\n  let alias = resolver?.alias;\n  if (!alias) {\n    const type = asArray(node[\"@type\"])?.[0] || \"\";\n    alias = type.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n  const hashNodeData = {};\n  Object.entries(node).forEach(([key, val]) => {\n    if (!key.startsWith(\"_\"))\n      hashNodeData[key] = val;\n  });\n  node[\"@id\"] = prefixId(ctx.meta[prefix], `#/schema/${alias}/${node[\"@id\"] || hashCode(JSON.stringify(hashNodeData))}`);\n  return node;\n}\nfunction resolveRelation(input, ctx, fallbackResolver, options = {}) {\n  if (!input)\n    return input;\n  const ids = asArray(input).map((a) => {\n    const keys = Object.keys(a).length;\n    if (keys === 1 && a[\"@id\"] || keys === 2 && a[\"@id\"] && a[\"@type\"]) {\n      return {\n        // we drop @type\n        \"@id\": ctx.find(a[\"@id\"])?.[\"@id\"] || a[\"@id\"]\n      };\n    }\n    let resolver = fallbackResolver;\n    if (a._resolver) {\n      resolver = a._resolver;\n      if (typeof resolver === \"string\")\n        resolver = loadResolver(resolver);\n      delete a._resolver;\n    }\n    if (!resolver)\n      return a;\n    let node = resolveNode(a, ctx, resolver);\n    if (options.afterResolve)\n      options.afterResolve(node);\n    if (options.generateId || options.root)\n      node = resolveNodeId(node, ctx, resolver, false);\n    if (options.root) {\n      if (resolver.resolveRootNode)\n        resolver.resolveRootNode(node, ctx);\n      ctx.push(node);\n      return idReference(node[\"@id\"]);\n    }\n    return node;\n  });\n  if (!options.array && ids.length === 1)\n    return ids[0];\n  return ids;\n}\n\nfunction isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\n\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isPlainObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\n\nfunction groupBy(array, predicate) {\n  return array.reduce((acc, value, index, array2) => {\n    const key = predicate(value, index, array2);\n    if (!acc[key])\n      acc[key] = [];\n    acc[key].push(value);\n    return acc;\n  }, {});\n}\nfunction uniqueBy(array, predicate) {\n  return Object.values(groupBy(array, predicate)).map((a) => a[a.length - 1]);\n}\nconst merge = createDefu((object, key, value) => {\n  if (Array.isArray(object[key])) {\n    object[key] = [.../* @__PURE__ */ new Set([...object[key], ...value])];\n    if (key === \"itemListElement\") {\n      object[key] = [...uniqueBy(object[key], (item) => item.position)];\n    }\n    return true;\n  }\n});\nfunction dedupeNodes(nodes) {\n  const dedupedNodes = {};\n  for (const key of nodes.keys()) {\n    const n = nodes[key];\n    const nodeKey = resolveAsGraphKey(n[\"@id\"] || hash(n));\n    if (dedupedNodes[nodeKey])\n      dedupedNodes[nodeKey] = merge(nodes[key], dedupedNodes[nodeKey]);\n    else\n      dedupedNodes[nodeKey] = nodes[key];\n  }\n  return Object.values(dedupedNodes);\n}\nfunction normaliseNodes(nodes) {\n  const sortedNodeKeys = nodes.keys();\n  const dedupedNodes = {};\n  for (const key of sortedNodeKeys) {\n    const n = nodes[key];\n    const nodeKey = resolveAsGraphKey(n[\"@id\"] || hash(n));\n    const groupedKeys = groupBy(Object.keys(n), (key2) => {\n      const val = n[key2];\n      if (key2.startsWith(\"_\"))\n        return \"ignored\";\n      if (Array.isArray(val) || typeof val === \"object\")\n        return \"relations\";\n      return \"primitives\";\n    });\n    const keys = [\n      ...(groupedKeys.primitives || []).sort(),\n      ...(groupedKeys.relations || []).sort()\n    ];\n    let newNode = {};\n    for (const key2 of keys)\n      newNode[key2] = n[key2];\n    if (dedupedNodes[nodeKey])\n      newNode = merge(newNode, dedupedNodes[nodeKey]);\n    dedupedNodes[nodeKey] = newNode;\n  }\n  return Object.values(dedupedNodes);\n}\n\nfunction createSchemaOrgGraph() {\n  const ctx = {\n    find(id) {\n      const key = resolveAsGraphKey(id);\n      return ctx.nodes.filter((n) => !!n[\"@id\"]).find((n) => resolveAsGraphKey(n[\"@id\"]) === key);\n    },\n    push(input) {\n      asArray(input).forEach((node) => {\n        const registeredNode = node;\n        ctx.nodes.push(registeredNode);\n      });\n    },\n    resolveGraph(meta) {\n      ctx.meta = resolveMeta({ ...meta });\n      ctx.nodes.forEach((node, key) => {\n        const resolver = node._resolver;\n        if (resolver) {\n          node = resolveNode(node, ctx, resolver);\n          node = resolveNodeId(node, ctx, resolver, true);\n        }\n        ctx.nodes[key] = node;\n      });\n      ctx.nodes = dedupeNodes(ctx.nodes);\n      ctx.nodes.forEach((node) => {\n        if (node.image && typeof node.image === \"string\") {\n          node.image = resolveRelation(node.image, ctx, imageResolver, {\n            root: true\n          });\n        }\n        if (node._resolver?.resolveRootNode)\n          node._resolver.resolveRootNode(node, ctx);\n        delete node._resolver;\n      });\n      return normaliseNodes(ctx.nodes);\n    },\n    nodes: [],\n    meta: {}\n  };\n  return ctx;\n}\n\nfunction UnheadSchemaOrg(options) {\n  return SchemaOrgUnheadPlugin({}, () => ({}), options);\n}\nfunction PluginSchemaOrg(options) {\n  const fallback = () => ({});\n  return SchemaOrgUnheadPlugin({}, options?.resolveMeta || fallback, options);\n}\nfunction SchemaOrgUnheadPlugin(config, meta, options) {\n  config = resolveMeta({ ...config });\n  let graph;\n  let resolvedMeta = {};\n  return defineHeadPlugin((head) => ({\n    key: \"schema-org\",\n    hooks: {\n      \"entries:resolve\": function() {\n        graph = createSchemaOrgGraph();\n      },\n      \"tag:normalise\": async function({ tag }) {\n        if (tag.key === \"schema-org-graph\") {\n          const { loadResolver } = await Promise.resolve().then(function () { return resolver; });\n          const nodes = await tag.props.nodes;\n          for (const node of Array.isArray(nodes) ? nodes : [nodes]) {\n            const newNode = {\n              ...node,\n              _resolver: loadResolver(await node._resolver)\n            };\n            graph.push(newNode);\n          }\n          tag.tagPosition = tag.tagPosition || config.tagPosition === \"head\" ? \"head\" : \"bodyClose\";\n        }\n        if (tag.tag === \"htmlAttrs\" && tag.props.lang) {\n          resolvedMeta.inLanguage = tag.props.lang;\n        } else if (tag.tag === \"title\") {\n          resolvedMeta.title = tag.textContent;\n        } else if (tag.tag === \"meta\" && tag.props.name === \"description\") {\n          resolvedMeta.description = tag.props.content;\n        } else if (tag.tag === \"link\" && tag.props.rel === \"canonical\") {\n          resolvedMeta.url = tag.props.href;\n          if (resolvedMeta.url && !resolvedMeta.host) {\n            try {\n              resolvedMeta.host = new URL(resolvedMeta.url).origin;\n            } catch {\n            }\n          }\n        } else if (tag.tag === \"meta\" && tag.props.property === \"og:image\") {\n          resolvedMeta.image = tag.props.content;\n        } else if (tag.tag === \"templateParams\" && tag.props.schemaOrg) {\n          resolvedMeta = {\n            ...resolvedMeta,\n            // @ts-expect-error untyped\n            ...tag.props.schemaOrg\n          };\n          delete tag.props.schemaOrg;\n        }\n      },\n      \"tags:resolve\": async function(ctx) {\n        for (const tag of ctx.tags) {\n          if (tag.tag === \"script\" && tag.key === \"schema-org-graph\") {\n            const minify = options?.minify || process.env.NODE_ENV === \"production\";\n            tag.innerHTML = JSON.stringify({\n              \"@context\": \"https://schema.org\",\n              \"@graph\": graph.resolveGraph({ ...await meta?.() || {}, ...config, ...resolvedMeta })\n            }, (_, value) => {\n              if (typeof value !== \"object\")\n                return processTemplateParams(value, head._templateParams, head._separator);\n              return value;\n            }, minify ? 0 : 2);\n            delete tag.props.nodes;\n            return;\n          }\n        }\n      }\n    }\n  }));\n}\n\nexport { webSiteResolver as $, itemListResolver as A, imageResolver as B, jobPostingResolver as C, listItemResolver as D, localBusinessResolver as E, movieResolver as F, offerResolver as G, HowToId as H, openingHoursResolver as I, organizationResolver as J, personResolver as K, addressResolver as L, ProductId as M, productResolver as N, questionResolver as O, PrimaryArticleId as P, ratingResolver as Q, RecipeId as R, recipeResolver as S, softwareAppResolver as T, UnheadSchemaOrg as U, reviewResolver as V, videoResolver as W, PrimaryWebPageId as X, webPageResolver as Y, readActionResolver as Z, PrimaryWebSiteId as _, dedupeNodes as a, searchActionResolver as a0, PluginSchemaOrg as a1, SchemaOrgUnheadPlugin as a2, resolveNode as b, createSchemaOrgGraph as c, defineSchemaOrgResolver as d, resolveNodeId as e, resolveRelation as f, aggregateOfferResolver as g, aggregateRatingResolver as h, articleResolver as i, bookEditionResolver as j, PrimaryBookId as k, bookResolver as l, PrimaryBreadcrumbId as m, normaliseNodes as n, breadcrumbResolver as o, commentResolver as p, courseResolver as q, resolveMeta as r, PrimaryEventId as s, eventResolver as t, placeResolver as u, virtualLocationResolver as v, foodEstablishmentResolver as w, howToResolver as x, howToStepResolver as y, howToStepDirectionResolver as z };\n",
      "start": 1708316410336,
      "end": 1708316410360,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1708316410360,
      "end": 1708316410360,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "result": "import { hashCode, defineHeadPlugin, processTemplateParams } from \"@unhead/shared\";\nimport { hasProtocol, withBase, withoutTrailingSlash, hasTrailingSlash, withTrailingSlash, joinURL } from \"ufo\";\nfunction defineSchemaOrgResolver(schema) {\n  return schema;\n}\nfunction idReference(node) {\n  return {\n    \"@id\": typeof node !== \"string\" ? node[\"@id\"] : node\n  };\n}\nfunction resolvableDateToDate(val) {\n  try {\n    const date = val instanceof Date ? val : new Date(Date.parse(val));\n    return `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;\n  } catch (e) {\n  }\n  return typeof val === \"string\" ? val : val.toString();\n}\nconst IS_VALID_W3C_DATE = [\n  /(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/,\n  /^\\d{4}-[01]\\d-[0-3]\\d$/,\n  /^\\d{4}-[01]\\d$/,\n  /^\\d{4}$/\n];\nfunction isValidW3CDate(d) {\n  return IS_VALID_W3C_DATE.some((r) => r.test(d));\n}\nfunction resolvableDateToIso(val) {\n  if (!val)\n    return val;\n  try {\n    if (val instanceof Date)\n      return val.toISOString();\n    else if (isValidW3CDate(val))\n      return val;\n    else\n      return new Date(Date.parse(val)).toISOString();\n  } catch (e) {\n  }\n  return typeof val === \"string\" ? val : val.toString();\n}\nconst IdentityId = \"#identity\";\nfunction setIfEmpty(node, field, value) {\n  if (!node?.[field] && value)\n    node[field] = value;\n}\nfunction asArray(input) {\n  return Array.isArray(input) ? input : [input];\n}\nfunction dedupeMerge(node, field, value) {\n  const dedupeMerge2 = [];\n  const input = asArray(node[field]);\n  dedupeMerge2.push(...input);\n  const data = new Set(dedupeMerge2);\n  data.add(value);\n  node[field] = [...data.values()].filter(Boolean);\n}\nfunction prefixId(url, id) {\n  if (hasProtocol(id))\n    return id;\n  if (!id.startsWith(\"#\"))\n    id = `#${id}`;\n  return withBase(id, url);\n}\nfunction trimLength(val, length) {\n  if (!val)\n    return val;\n  if (val.length > length) {\n    const trimmedString = val.substring(0, length);\n    return trimmedString.substring(0, Math.min(trimmedString.length, trimmedString.lastIndexOf(\" \")));\n  }\n  return val;\n}\nfunction resolveDefaultType(node, defaultType) {\n  const val = node[\"@type\"];\n  if (val === defaultType)\n    return;\n  const types = /* @__PURE__ */ new Set([\n    ...asArray(defaultType),\n    ...asArray(val)\n  ]);\n  node[\"@type\"] = types.size === 1 ? val : [...types.values()];\n}\nfunction resolveWithBase(base, urlOrPath) {\n  if (!urlOrPath || hasProtocol(urlOrPath) || !urlOrPath.startsWith(\"/\") && !urlOrPath.startsWith(\"#\"))\n    return urlOrPath;\n  return withBase(urlOrPath, base);\n}\nfunction resolveAsGraphKey(key) {\n  if (!key)\n    return key;\n  return key.substring(key.lastIndexOf(\"#\"));\n}\nfunction stripEmptyProperties(obj) {\n  Object.keys(obj).forEach((k) => {\n    if (obj[k] && typeof obj[k] === \"object\") {\n      if (obj[k].__v_isReadonly || obj[k].__v_isRef)\n        return;\n      stripEmptyProperties(obj[k]);\n      return;\n    }\n    if (obj[k] === \"\" || obj[k] === null || typeof obj[k] === \"undefined\")\n      delete obj[k];\n  });\n  return obj;\n}\nconst offerResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"number\" || typeof node === \"string\") {\n      return {\n        price: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Offer\",\n    \"availability\": \"InStock\"\n  },\n  resolve(node, ctx) {\n    setIfEmpty(node, \"priceCurrency\", ctx.meta.currency);\n    setIfEmpty(node, \"priceValidUntil\", new Date(Date.UTC((/* @__PURE__ */ new Date()).getFullYear() + 1, 12, -1, 0, 0, 0)));\n    if (node.url)\n      resolveWithBase(ctx.meta.host, node.url);\n    if (node.availability)\n      node.availability = withBase(node.availability, \"https://schema.org/\");\n    if (node.priceValidUntil)\n      node.priceValidUntil = resolvableDateToIso(node.priceValidUntil);\n    return node;\n  }\n});\nconst aggregateOfferResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"AggregateOffer\"\n  },\n  inheritMeta: [\n    { meta: \"currency\", key: \"priceCurrency\" }\n  ],\n  resolve(node, ctx) {\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    if (node.offers)\n      setIfEmpty(node, \"offerCount\", asArray(node.offers).length);\n    return node;\n  }\n});\nconst aggregateRatingResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"AggregateRating\"\n  }\n});\nconst searchActionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"SearchAction\",\n    \"target\": {\n      \"@type\": \"EntryPoint\"\n    },\n    \"query-input\": {\n      \"@type\": \"PropertyValueSpecification\",\n      \"valueRequired\": true,\n      \"valueName\": \"search_term_string\"\n    }\n  },\n  resolve(node, ctx) {\n    if (typeof node.target === \"string\") {\n      node.target = {\n        \"@type\": \"EntryPoint\",\n        \"urlTemplate\": resolveWithBase(ctx.meta.host, node.target)\n      };\n    }\n    return node;\n  }\n});\nconst PrimaryWebSiteId = \"#website\";\nconst webSiteResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"WebSite\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    { meta: \"host\", key: \"url\" }\n  ],\n  idPrefix: [\"host\", PrimaryWebSiteId],\n  resolve(node, ctx) {\n    node.potentialAction = resolveRelation(node.potentialAction, ctx, searchActionResolver, {\n      array: true\n    });\n    node.publisher = resolveRelation(node.publisher, ctx);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    if (resolveAsGraphKey(node[\"@id\"]) === PrimaryWebSiteId) {\n      const identity = find(IdentityId);\n      if (identity)\n        setIfEmpty(node, \"publisher\", idReference(identity));\n      const webPage = find(PrimaryWebPageId);\n      if (webPage)\n        setIfEmpty(webPage, \"isPartOf\", idReference(node));\n    }\n    return node;\n  }\n});\nconst listItemResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      node = {\n        name: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"ListItem\"\n  },\n  resolve(node, ctx) {\n    if (typeof node.item === \"string\")\n      node.item = resolveWithBase(ctx.meta.host, node.item);\n    else if (typeof node.item === \"object\")\n      node.item = resolveRelation(node.item, ctx);\n    return node;\n  }\n});\nconst PrimaryBreadcrumbId = \"#breadcrumb\";\nconst breadcrumbResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"BreadcrumbList\"\n  },\n  idPrefix: [\"url\", PrimaryBreadcrumbId],\n  resolve(breadcrumb, ctx) {\n    if (breadcrumb.itemListElement) {\n      let index = 1;\n      breadcrumb.itemListElement = resolveRelation(breadcrumb.itemListElement, ctx, listItemResolver, {\n        array: true,\n        afterResolve(node) {\n          setIfEmpty(node, \"position\", index++);\n        }\n      });\n    }\n    return breadcrumb;\n  },\n  resolveRootNode(node, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage)\n      setIfEmpty(webPage, \"breadcrumb\", idReference(node));\n  }\n});\nconst imageResolver = defineSchemaOrgResolver({\n  alias: \"image\",\n  cast(input) {\n    if (typeof input === \"string\") {\n      input = {\n        url: input\n      };\n    }\n    return input;\n  },\n  defaults: {\n    \"@type\": \"ImageObject\"\n  },\n  inheritMeta: [\n    // @todo possibly only do if there's a caption\n    \"inLanguage\"\n  ],\n  idPrefix: \"host\",\n  resolve(image, { meta }) {\n    image.url = resolveWithBase(meta.host, image.url);\n    setIfEmpty(image, \"contentUrl\", image.url);\n    if (image.height && !image.width)\n      delete image.height;\n    if (image.width && !image.height)\n      delete image.width;\n    return image;\n  }\n});\nconst addressResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"PostalAddress\"\n  }\n});\nconst organizationResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Organization\"\n  },\n  idPrefix: [\"host\", IdentityId],\n  inheritMeta: [\n    { meta: \"host\", key: \"url\" }\n  ],\n  resolve(node, ctx) {\n    resolveDefaultType(node, \"Organization\");\n    node.address = resolveRelation(node.address, ctx, addressResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    const isIdentity = resolveAsGraphKey(node[\"@id\"]) === IdentityId;\n    const webPage = ctx.find(PrimaryWebPageId);\n    if (node.logo && isIdentity) {\n      if (!ctx.find(\"#organization\")) {\n        const logoNode = resolveRelation(node.logo, ctx, imageResolver, {\n          root: true,\n          afterResolve(logo) {\n            logo[\"@id\"] = prefixId(ctx.meta.host, \"#logo\");\n            setIfEmpty(logo, \"caption\", node.name);\n          }\n        });\n        if (webPage && logoNode)\n          setIfEmpty(webPage, \"primaryImageOfPage\", idReference(logoNode));\n        ctx.nodes.push({\n          // we want to make a simple node that has the essentials, this will allow parent nodes to inject\n          // as well without inserting invalid data (i.e LocalBusiness operatingHours)\n          \"@type\": \"Organization\",\n          \"name\": node.name,\n          \"url\": node.url,\n          \"sameAs\": node.sameAs,\n          // 'image': idReference(logoNode),\n          \"address\": node.address,\n          // needs to be a URL\n          \"logo\": resolveRelation(node.logo, ctx, imageResolver, { root: false }).url,\n          \"_priority\": -1,\n          \"@id\": prefixId(ctx.meta.host, \"#organization\")\n          // avoid the id so nothing can link to it\n        });\n      }\n      delete node.logo;\n    }\n    if (isIdentity && webPage)\n      setIfEmpty(webPage, \"about\", idReference(node));\n    const webSite = ctx.find(PrimaryWebSiteId);\n    if (webSite)\n      setIfEmpty(webSite, \"publisher\", idReference(node));\n  }\n});\nconst personResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        name: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Person\"\n  },\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    if (node.url)\n      node.url = resolveWithBase(ctx.meta.host, node.url);\n    return node;\n  },\n  resolveRootNode(node, { find, meta }) {\n    if (resolveAsGraphKey(node[\"@id\"]) === IdentityId) {\n      setIfEmpty(node, \"url\", meta.host);\n      const webPage = find(PrimaryWebPageId);\n      if (webPage)\n        setIfEmpty(webPage, \"about\", idReference(node));\n      const webSite = find(PrimaryWebSiteId);\n      if (webSite)\n        setIfEmpty(webSite, \"publisher\", idReference(node));\n    }\n    const article = find(PrimaryArticleId);\n    if (article)\n      setIfEmpty(article, \"author\", idReference(node));\n  }\n});\nconst readActionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"ReadAction\"\n  },\n  resolve(node, ctx) {\n    if (!node.target.includes(ctx.meta.url))\n      node.target.unshift(ctx.meta.url);\n    return node;\n  }\n});\nconst PrimaryWebPageId = \"#webpage\";\nconst webPageResolver = defineSchemaOrgResolver({\n  defaults({ meta }) {\n    const endPath = withoutTrailingSlash(meta.url.substring(meta.url.lastIndexOf(\"/\") + 1));\n    let type = \"WebPage\";\n    switch (endPath) {\n      case \"about\":\n      case \"about-us\":\n        type = \"AboutPage\";\n        break;\n      case \"search\":\n        type = \"SearchResultsPage\";\n        break;\n      case \"checkout\":\n        type = \"CheckoutPage\";\n        break;\n      case \"contact\":\n      case \"get-in-touch\":\n      case \"contact-us\":\n        type = \"ContactPage\";\n        break;\n      case \"faq\":\n        type = \"FAQPage\";\n        break;\n    }\n    const defaults2 = {\n      \"@type\": type\n    };\n    return defaults2;\n  },\n  idPrefix: [\"url\", PrimaryWebPageId],\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"datePublished\",\n    \"dateModified\",\n    \"url\"\n  ],\n  resolve(node, ctx) {\n    node.dateModified = resolvableDateToIso(node.dateModified);\n    node.datePublished = resolvableDateToIso(node.datePublished);\n    resolveDefaultType(node, \"WebPage\");\n    node.about = resolveRelation(node.about, ctx, organizationResolver);\n    node.breadcrumb = resolveRelation(node.breadcrumb, ctx, breadcrumbResolver);\n    node.author = resolveRelation(node.author, ctx, personResolver);\n    node.primaryImageOfPage = resolveRelation(node.primaryImageOfPage, ctx, imageResolver);\n    node.potentialAction = resolveRelation(node.potentialAction, ctx, readActionResolver);\n    if (node[\"@type\"] === \"WebPage\" && ctx.meta.url) {\n      setIfEmpty(node, \"potentialAction\", [\n        {\n          \"@type\": \"ReadAction\",\n          \"target\": [ctx.meta.url]\n        }\n      ]);\n    }\n    return node;\n  },\n  resolveRootNode(webPage, { find, meta }) {\n    const identity = find(IdentityId);\n    const webSite = find(PrimaryWebSiteId);\n    const logo = find(\"#logo\");\n    if (identity && meta.url === meta.host)\n      setIfEmpty(webPage, \"about\", idReference(identity));\n    if (logo)\n      setIfEmpty(webPage, \"primaryImageOfPage\", idReference(logo));\n    if (webSite)\n      setIfEmpty(webPage, \"isPartOf\", idReference(webSite));\n    const breadcrumb = find(PrimaryBreadcrumbId);\n    if (breadcrumb)\n      setIfEmpty(webPage, \"breadcrumb\", idReference(breadcrumb));\n    return webPage;\n  }\n});\nconst PrimaryArticleId = \"#article\";\nconst articleResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Article\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    \"description\",\n    \"image\",\n    \"dateModified\",\n    \"datePublished\",\n    { meta: \"title\", key: \"headline\" }\n  ],\n  idPrefix: [\"url\", PrimaryArticleId],\n  resolve(node, ctx) {\n    node.author = resolveRelation(node.author, ctx, personResolver, {\n      root: true\n    });\n    node.publisher = resolveRelation(node.publisher, ctx);\n    node.dateModified = resolvableDateToIso(node.dateModified);\n    node.datePublished = resolvableDateToIso(node.datePublished);\n    resolveDefaultType(node, \"Article\");\n    node.headline = trimLength(node.headline, 110);\n    return node;\n  },\n  resolveRootNode(node, { find, meta }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (node.image && !node.thumbnailUrl) {\n      const firstImage = asArray(node.image)[0];\n      if (typeof firstImage === \"string\")\n        setIfEmpty(node, \"thumbnailUrl\", resolveWithBase(meta.host, firstImage));\n      else if (firstImage?.[\"@id\"])\n        setIfEmpty(node, \"thumbnailUrl\", find(firstImage[\"@id\"])?.url);\n    }\n    if (identity) {\n      setIfEmpty(node, \"publisher\", idReference(identity));\n      setIfEmpty(node, \"author\", idReference(identity));\n    }\n    if (webPage) {\n      setIfEmpty(node, \"isPartOf\", idReference(webPage));\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n      setIfEmpty(webPage, \"potentialAction\", [\n        {\n          \"@type\": \"ReadAction\",\n          \"target\": [meta.url]\n        }\n      ]);\n      setIfEmpty(webPage, \"dateModified\", node.dateModified);\n      setIfEmpty(webPage, \"datePublished\", node.datePublished);\n    }\n    return node;\n  }\n});\nconst bookEditionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Book\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  resolve(node, ctx) {\n    if (node.bookFormat)\n      node.bookFormat = withBase(node.bookFormat, \"https://schema.org/\");\n    if (node.datePublished)\n      node.datePublished = resolvableDateToDate(node.datePublished);\n    node.author = resolveRelation(node.author, ctx);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"provider\", idReference(identity));\n    return node;\n  }\n});\nconst PrimaryBookId = \"#book\";\nconst bookResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Book\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"url\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", PrimaryBookId],\n  resolve(node, ctx) {\n    node.workExample = resolveRelation(node.workExample, ctx, bookEditionResolver);\n    node.author = resolveRelation(node.author, ctx);\n    if (node.url)\n      withBase(node.url, ctx.meta.host);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"author\", idReference(identity));\n    return node;\n  }\n});\nconst commentResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Comment\"\n  },\n  idPrefix: \"url\",\n  resolve(node, ctx) {\n    node.author = resolveRelation(node.author, ctx, personResolver, {\n      root: true\n    });\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const article = find(PrimaryArticleId);\n    if (article)\n      setIfEmpty(node, \"about\", idReference(article));\n  }\n});\nconst courseResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Course\"\n  },\n  resolve(node, ctx) {\n    node.provider = resolveRelation(node.provider, ctx, organizationResolver, {\n      root: true\n    });\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"provider\", idReference(identity));\n    return node;\n  }\n});\nconst placeResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Place\"\n  },\n  resolve(node, ctx) {\n    if (typeof node.address !== \"string\")\n      node.address = resolveRelation(node.address, ctx, addressResolver);\n    return node;\n  }\n});\nconst virtualLocationResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        url: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"VirtualLocation\"\n  }\n});\nconst PrimaryEventId = \"#event\";\nconst eventResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Event\"\n  },\n  inheritMeta: [\n    \"inLanguage\",\n    \"description\",\n    \"image\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", PrimaryEventId],\n  resolve(node, ctx) {\n    if (node.location) {\n      const isVirtual = node.location === \"string\" || node.location?.url !== \"undefined\";\n      node.location = resolveRelation(node.location, ctx, isVirtual ? virtualLocationResolver : placeResolver);\n    }\n    node.performer = resolveRelation(node.performer, ctx, personResolver, {\n      root: true\n    });\n    node.organizer = resolveRelation(node.organizer, ctx, organizationResolver, {\n      root: true\n    });\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    if (node.eventAttendanceMode)\n      node.eventAttendanceMode = withBase(node.eventAttendanceMode, \"https://schema.org/\");\n    if (node.eventStatus)\n      node.eventStatus = withBase(node.eventStatus, \"https://schema.org/\");\n    const isOnline = node.eventStatus === \"https://schema.org/EventMovedOnline\";\n    const dates = [\"startDate\", \"previousStartDate\", \"endDate\"];\n    dates.forEach((date) => {\n      if (!isOnline) {\n        if (node[date] instanceof Date && node[date].getHours() === 0 && node[date].getMinutes() === 0)\n          node[date] = resolvableDateToDate(node[date]);\n      } else {\n        node[date] = resolvableDateToIso(node[date]);\n      }\n    });\n    setIfEmpty(node, \"endDate\", node.startDate);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(node, \"organizer\", idReference(identity));\n  }\n});\nconst ratingResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (node === \"number\") {\n      return {\n        ratingValue: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Rating\",\n    \"bestRating\": 5,\n    \"worstRating\": 1\n  }\n});\nconst openingHoursResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"OpeningHoursSpecification\",\n    \"opens\": \"00:00\",\n    \"closes\": \"23:59\"\n  }\n});\nconst localBusinessResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": [\"Organization\", \"LocalBusiness\"]\n  },\n  inheritMeta: [\n    { key: \"url\", meta: \"host\" },\n    { key: \"currenciesAccepted\", meta: \"currency\" }\n  ],\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    resolveDefaultType(node, [\"Organization\", \"LocalBusiness\"]);\n    node.address = resolveRelation(node.address, ctx, addressResolver);\n    node.openingHoursSpecification = resolveRelation(node.openingHoursSpecification, ctx, openingHoursResolver);\n    node = resolveNode({ ...node }, ctx, organizationResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    organizationResolver.resolveRootNode(node, ctx);\n    return node;\n  }\n});\nconst foodEstablishmentResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": [\"Organization\", \"LocalBusiness\", \"FoodEstablishment\"]\n  },\n  inheritMeta: [\n    { key: \"url\", meta: \"host\" },\n    { key: \"currenciesAccepted\", meta: \"currency\" }\n  ],\n  idPrefix: [\"host\", IdentityId],\n  resolve(node, ctx) {\n    resolveDefaultType(node, [\"Organization\", \"LocalBusiness\", \"FoodEstablishment\"]);\n    node.starRating = resolveRelation(node.starRating, ctx, ratingResolver);\n    node = resolveNode(node, ctx, localBusinessResolver);\n    return node;\n  },\n  resolveRootNode(node, ctx) {\n    localBusinessResolver.resolveRootNode(node, ctx);\n    return node;\n  }\n});\nconst howToStepDirectionResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"HowToDirection\"\n  }\n});\nconst howToStepResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"HowToStep\"\n  },\n  resolve(step, ctx) {\n    if (step.url)\n      step.url = resolveWithBase(ctx.meta.url, step.url);\n    if (step.image) {\n      step.image = resolveRelation(step.image, ctx, imageResolver, {\n        root: true\n      });\n    }\n    if (step.itemListElement)\n      step.itemListElement = resolveRelation(step.itemListElement, ctx, howToStepDirectionResolver);\n    return step;\n  }\n});\nconst HowToId = \"#howto\";\nconst howToResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"HowTo\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"image\",\n    \"inLanguage\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", HowToId],\n  resolve(node, ctx) {\n    node.step = resolveRelation(node.step, ctx, howToStepResolver);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n  }\n});\nconst itemListResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"ItemList\"\n  },\n  resolve(node, ctx) {\n    if (node.itemListElement) {\n      let index = 1;\n      node.itemListElement = resolveRelation(node.itemListElement, ctx, listItemResolver, {\n        array: true,\n        afterResolve(node2) {\n          setIfEmpty(node2, \"position\", index++);\n        }\n      });\n    }\n    return node;\n  }\n});\nconst quantitativeValueResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"QuantitativeValue\"\n  }\n});\nconst monetaryAmountResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"MonetaryAmount\"\n  },\n  resolve(node, ctx) {\n    node.value = resolveRelation(node.value, ctx, quantitativeValueResolver);\n    return node;\n  }\n});\nconst jobPostingResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"JobPosting\"\n  },\n  idPrefix: [\"url\", \"#job-posting\"],\n  resolve(node, ctx) {\n    node.datePosted = resolvableDateToIso(node.datePosted);\n    node.hiringOrganization = resolveRelation(node.hiringOrganization, ctx, organizationResolver);\n    node.jobLocation = resolveRelation(node.jobLocation, ctx, placeResolver);\n    node.baseSalary = resolveRelation(node.baseSalary, ctx, monetaryAmountResolver);\n    node.validThrough = resolvableDateToIso(node.validThrough);\n    return node;\n  },\n  resolveRootNode(jobPosting, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(jobPosting, \"hiringOrganization\", idReference(identity));\n    if (webPage)\n      setIfEmpty(jobPosting, \"mainEntityOfPage\", idReference(webPage));\n    return jobPosting;\n  }\n});\nconst reviewResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Review\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  resolve(review, ctx) {\n    review.reviewRating = resolveRelation(review.reviewRating, ctx, ratingResolver);\n    review.author = resolveRelation(review.author, ctx, personResolver);\n    return review;\n  }\n});\nconst videoResolver = defineSchemaOrgResolver({\n  cast(input) {\n    if (typeof input === \"string\") {\n      input = {\n        url: input\n      };\n    }\n    return input;\n  },\n  alias: \"video\",\n  defaults: {\n    \"@type\": \"VideoObject\"\n  },\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"image\",\n    \"inLanguage\",\n    { meta: \"datePublished\", key: \"uploadDate\" }\n  ],\n  idPrefix: \"host\",\n  resolve(video, ctx) {\n    if (video.uploadDate)\n      video.uploadDate = resolvableDateToIso(video.uploadDate);\n    video.url = resolveWithBase(ctx.meta.host, video.url);\n    if (video.caption && !video.description)\n      video.description = video.caption;\n    if (!video.description)\n      video.description = \"No description\";\n    if (video.thumbnailUrl)\n      video.thumbnailUrl = resolveRelation(video.thumbnailUrl, ctx, imageResolver);\n    return video;\n  },\n  resolveRootNode(video, { find }) {\n    if (video.image && !video.thumbnailUrl) {\n      const firstImage = asArray(video.image)[0];\n      setIfEmpty(video, \"thumbnailUrl\", find(firstImage[\"@id\"])?.url);\n    }\n  }\n});\nconst movieResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Movie\"\n  },\n  resolve(node, ctx) {\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    node.director = resolveRelation(node.director, ctx, personResolver);\n    node.actor = resolveRelation(node.actor, ctx, personResolver);\n    node.trailer = resolveRelation(node.trailer, ctx, videoResolver);\n    if (node.dateCreated)\n      node.dateCreated = resolvableDateToDate(node.dateCreated);\n    return node;\n  }\n});\nconst defaults = Object.freeze({\n  ignoreUnknown: false,\n  respectType: false,\n  respectFunctionNames: false,\n  respectFunctionProperties: false,\n  unorderedObjects: true,\n  unorderedArrays: false,\n  unorderedSets: false,\n  excludeKeys: void 0,\n  excludeValues: void 0,\n  replacer: void 0\n});\nfunction objectHash(object, options) {\n  if (options) {\n    options = { ...defaults, ...options };\n  } else {\n    options = defaults;\n  }\n  const hasher = createHasher(options);\n  hasher.dispatch(object);\n  return hasher.toString();\n}\nconst defaultPrototypesKeys = Object.freeze([\n  \"prototype\",\n  \"__proto__\",\n  \"constructor\"\n]);\nfunction createHasher(options) {\n  let buff = \"\";\n  let context = /* @__PURE__ */ new Map();\n  const write = (str) => {\n    buff += str;\n  };\n  return {\n    toString() {\n      return buff;\n    },\n    getContext() {\n      return context;\n    },\n    dispatch(value) {\n      if (options.replacer) {\n        value = options.replacer(value);\n      }\n      const type = value === null ? \"null\" : typeof value;\n      return this[type](value);\n    },\n    object(object) {\n      if (object && typeof object.toJSON === \"function\") {\n        return this.object(object.toJSON());\n      }\n      const objString = Object.prototype.toString.call(object);\n      let objType = \"\";\n      const objectLength = objString.length;\n      if (objectLength < 10) {\n        objType = \"unknown:[\" + objString + \"]\";\n      } else {\n        objType = objString.slice(8, objectLength - 1);\n      }\n      objType = objType.toLowerCase();\n      let objectNumber = null;\n      if ((objectNumber = context.get(object)) === void 0) {\n        context.set(object, context.size);\n      } else {\n        return this.dispatch(\"[CIRCULAR:\" + objectNumber + \"]\");\n      }\n      if (typeof Buffer !== \"undefined\" && Buffer.isBuffer && Buffer.isBuffer(object)) {\n        write(\"buffer:\");\n        return write(object.toString(\"utf8\"));\n      }\n      if (objType !== \"object\" && objType !== \"function\" && objType !== \"asyncfunction\") {\n        if (this[objType]) {\n          this[objType](object);\n        } else if (!options.ignoreUnknown) {\n          this.unkown(object, objType);\n        }\n      } else {\n        let keys = Object.keys(object);\n        if (options.unorderedObjects) {\n          keys = keys.sort();\n        }\n        let extraKeys = [];\n        if (options.respectType !== false && !isNativeFunction(object)) {\n          extraKeys = defaultPrototypesKeys;\n        }\n        if (options.excludeKeys) {\n          keys = keys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n          extraKeys = extraKeys.filter((key) => {\n            return !options.excludeKeys(key);\n          });\n        }\n        write(\"object:\" + (keys.length + extraKeys.length) + \":\");\n        const dispatchForKey = (key) => {\n          this.dispatch(key);\n          write(\":\");\n          if (!options.excludeValues) {\n            this.dispatch(object[key]);\n          }\n          write(\",\");\n        };\n        for (const key of keys) {\n          dispatchForKey(key);\n        }\n        for (const key of extraKeys) {\n          dispatchForKey(key);\n        }\n      }\n    },\n    array(arr, unordered) {\n      unordered = unordered === void 0 ? options.unorderedArrays !== false : unordered;\n      write(\"array:\" + arr.length + \":\");\n      if (!unordered || arr.length <= 1) {\n        for (const entry of arr) {\n          this.dispatch(entry);\n        }\n        return;\n      }\n      const contextAdditions = /* @__PURE__ */ new Map();\n      const entries = arr.map((entry) => {\n        const hasher = createHasher(options);\n        hasher.dispatch(entry);\n        for (const [key, value] of hasher.getContext()) {\n          contextAdditions.set(key, value);\n        }\n        return hasher.toString();\n      });\n      context = contextAdditions;\n      entries.sort();\n      return this.array(entries, false);\n    },\n    date(date) {\n      return write(\"date:\" + date.toJSON());\n    },\n    symbol(sym) {\n      return write(\"symbol:\" + sym.toString());\n    },\n    unkown(value, type) {\n      write(type);\n      if (!value) {\n        return;\n      }\n      write(\":\");\n      if (value && typeof value.entries === \"function\") {\n        return this.array(\n          Array.from(value.entries()),\n          true\n          /* ordered */\n        );\n      }\n    },\n    error(err) {\n      return write(\"error:\" + err.toString());\n    },\n    boolean(bool) {\n      return write(\"bool:\" + bool);\n    },\n    string(string) {\n      write(\"string:\" + string.length + \":\");\n      write(string);\n    },\n    function(fn) {\n      write(\"fn:\");\n      if (isNativeFunction(fn)) {\n        this.dispatch(\"[native]\");\n      } else {\n        this.dispatch(fn.toString());\n      }\n      if (options.respectFunctionNames !== false) {\n        this.dispatch(\"function-name:\" + String(fn.name));\n      }\n      if (options.respectFunctionProperties) {\n        this.object(fn);\n      }\n    },\n    number(number) {\n      return write(\"number:\" + number);\n    },\n    xml(xml) {\n      return write(\"xml:\" + xml.toString());\n    },\n    null() {\n      return write(\"Null\");\n    },\n    undefined() {\n      return write(\"Undefined\");\n    },\n    regexp(regex) {\n      return write(\"regex:\" + regex.toString());\n    },\n    uint8array(arr) {\n      write(\"uint8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint8clampedarray(arr) {\n      write(\"uint8clampedarray:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int8array(arr) {\n      write(\"int8array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint16array(arr) {\n      write(\"uint16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int16array(arr) {\n      write(\"int16array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    uint32array(arr) {\n      write(\"uint32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    int32array(arr) {\n      write(\"int32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float32array(arr) {\n      write(\"float32array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    float64array(arr) {\n      write(\"float64array:\");\n      return this.dispatch(Array.prototype.slice.call(arr));\n    },\n    arraybuffer(arr) {\n      write(\"arraybuffer:\");\n      return this.dispatch(new Uint8Array(arr));\n    },\n    url(url) {\n      return write(\"url:\" + url.toString());\n    },\n    map(map) {\n      write(\"map:\");\n      const arr = [...map];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    set(set) {\n      write(\"set:\");\n      const arr = [...set];\n      return this.array(arr, options.unorderedSets !== false);\n    },\n    file(file) {\n      write(\"file:\");\n      return this.dispatch([file.name, file.size, file.type, file.lastModfied]);\n    },\n    blob() {\n      if (options.ignoreUnknown) {\n        return write(\"[blob]\");\n      }\n      throw new Error(\n        'Hashing Blob objects is currently not supported\\nUse \"options.replacer\" or \"options.ignoreUnknown\"\\n'\n      );\n    },\n    domwindow() {\n      return write(\"domwindow\");\n    },\n    bigint(number) {\n      return write(\"bigint:\" + number.toString());\n    },\n    /* Node.js standard native objects */\n    process() {\n      return write(\"process\");\n    },\n    timer() {\n      return write(\"timer\");\n    },\n    pipe() {\n      return write(\"pipe\");\n    },\n    tcp() {\n      return write(\"tcp\");\n    },\n    udp() {\n      return write(\"udp\");\n    },\n    tty() {\n      return write(\"tty\");\n    },\n    statwatcher() {\n      return write(\"statwatcher\");\n    },\n    securecontext() {\n      return write(\"securecontext\");\n    },\n    connection() {\n      return write(\"connection\");\n    },\n    zlib() {\n      return write(\"zlib\");\n    },\n    context() {\n      return write(\"context\");\n    },\n    nodescript() {\n      return write(\"nodescript\");\n    },\n    httpparser() {\n      return write(\"httpparser\");\n    },\n    dataview() {\n      return write(\"dataview\");\n    },\n    signal() {\n      return write(\"signal\");\n    },\n    fsevent() {\n      return write(\"fsevent\");\n    },\n    tlswrap() {\n      return write(\"tlswrap\");\n    }\n  };\n}\nconst nativeFunc = \"[native code] }\";\nconst nativeFuncLength = nativeFunc.length;\nfunction isNativeFunction(f) {\n  if (typeof f !== \"function\") {\n    return false;\n  }\n  return Function.prototype.toString.call(f).slice(-nativeFuncLength) === nativeFunc;\n}\nclass WordArray {\n  constructor(words, sigBytes) {\n    words = this.words = words || [];\n    this.sigBytes = sigBytes === void 0 ? words.length * 4 : sigBytes;\n  }\n  toString(encoder) {\n    return (encoder || Hex).stringify(this);\n  }\n  concat(wordArray) {\n    this.clamp();\n    if (this.sigBytes % 4) {\n      for (let i = 0; i < wordArray.sigBytes; i++) {\n        const thatByte = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n        this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n      }\n    } else {\n      for (let j = 0; j < wordArray.sigBytes; j += 4) {\n        this.words[this.sigBytes + j >>> 2] = wordArray.words[j >>> 2];\n      }\n    }\n    this.sigBytes += wordArray.sigBytes;\n    return this;\n  }\n  clamp() {\n    this.words[this.sigBytes >>> 2] &= 4294967295 << 32 - this.sigBytes % 4 * 8;\n    this.words.length = Math.ceil(this.sigBytes / 4);\n  }\n  clone() {\n    return new WordArray([...this.words]);\n  }\n}\nconst Hex = {\n  stringify(wordArray) {\n    const hexChars = [];\n    for (let i = 0; i < wordArray.sigBytes; i++) {\n      const bite = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      hexChars.push((bite >>> 4).toString(16), (bite & 15).toString(16));\n    }\n    return hexChars.join(\"\");\n  }\n};\nconst Base64 = {\n  stringify(wordArray) {\n    const keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const base64Chars = [];\n    for (let i = 0; i < wordArray.sigBytes; i += 3) {\n      const byte1 = wordArray.words[i >>> 2] >>> 24 - i % 4 * 8 & 255;\n      const byte2 = wordArray.words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;\n      const byte3 = wordArray.words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;\n      const triplet = byte1 << 16 | byte2 << 8 | byte3;\n      for (let j = 0; j < 4 && i * 8 + j * 6 < wordArray.sigBytes * 8; j++) {\n        base64Chars.push(keyStr.charAt(triplet >>> 6 * (3 - j) & 63));\n      }\n    }\n    return base64Chars.join(\"\");\n  }\n};\nconst Latin1 = {\n  parse(latin1Str) {\n    const latin1StrLength = latin1Str.length;\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i++) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;\n    }\n    return new WordArray(words, latin1StrLength);\n  }\n};\nconst Utf8 = {\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  }\n};\nclass BufferedBlockAlgorithm {\n  constructor() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n    this._minBufferSize = 0;\n    this.blockSize = 512 / 32;\n  }\n  reset() {\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n  _append(data) {\n    if (typeof data === \"string\") {\n      data = Utf8.parse(data);\n    }\n    this._data.concat(data);\n    this._nDataBytes += data.sigBytes;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _doProcessBlock(_dataWords, _offset) {\n  }\n  _process(doFlush) {\n    let processedWords;\n    let nBlocksReady = this._data.sigBytes / (this.blockSize * 4);\n    if (doFlush) {\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n    const nWordsReady = nBlocksReady * this.blockSize;\n    const nBytesReady = Math.min(nWordsReady * 4, this._data.sigBytes);\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += this.blockSize) {\n        this._doProcessBlock(this._data.words, offset);\n      }\n      processedWords = this._data.words.splice(0, nWordsReady);\n      this._data.sigBytes -= nBytesReady;\n    }\n    return new WordArray(processedWords, nBytesReady);\n  }\n}\nclass Hasher extends BufferedBlockAlgorithm {\n  update(messageUpdate) {\n    this._append(messageUpdate);\n    this._process();\n    return this;\n  }\n  finalize(messageUpdate) {\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n  }\n}\nconst H = [\n  1779033703,\n  -1150833019,\n  1013904242,\n  -1521486534,\n  1359893119,\n  -1694144372,\n  528734635,\n  1541459225\n];\nconst K = [\n  1116352408,\n  1899447441,\n  -1245643825,\n  -373957723,\n  961987163,\n  1508970993,\n  -1841331548,\n  -1424204075,\n  -670586216,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  -2132889090,\n  -1680079193,\n  -1046744716,\n  -459576895,\n  -272742522,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  -1740746414,\n  -1473132947,\n  -1341970488,\n  -1084653625,\n  -958395405,\n  -710438585,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  -2117940946,\n  -1838011259,\n  -1564481375,\n  -1474664885,\n  -1035236496,\n  -949202525,\n  -778901479,\n  -694614492,\n  -200395387,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  -2067236844,\n  -1933114872,\n  -1866530822,\n  -1538233109,\n  -1090935817,\n  -965641998\n];\nconst W = [];\nclass SHA256 extends Hasher {\n  constructor() {\n    super(...arguments);\n    this._hash = new WordArray([...H]);\n  }\n  reset() {\n    super.reset();\n    this._hash = new WordArray([...H]);\n  }\n  _doProcessBlock(M, offset) {\n    const H2 = this._hash.words;\n    let a = H2[0];\n    let b = H2[1];\n    let c = H2[2];\n    let d = H2[3];\n    let e = H2[4];\n    let f = H2[5];\n    let g = H2[6];\n    let h = H2[7];\n    for (let i = 0; i < 64; i++) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n        const gamma1x = W[i - 2];\n        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n      const ch = e & f ^ ~e & g;\n      const maj = a & b ^ a & c ^ b & c;\n      const sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 | 0;\n    }\n    H2[0] = H2[0] + a | 0;\n    H2[1] = H2[1] + b | 0;\n    H2[2] = H2[2] + c | 0;\n    H2[3] = H2[3] + d | 0;\n    H2[4] = H2[4] + e | 0;\n    H2[5] = H2[5] + f | 0;\n    H2[6] = H2[6] + g | 0;\n    H2[7] = H2[7] + h | 0;\n  }\n  finalize(messageUpdate) {\n    super.finalize(messageUpdate);\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = this._data.sigBytes * 8;\n    this._data.words[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(\n      nBitsTotal / 4294967296\n    );\n    this._data.words[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n    this._data.sigBytes = this._data.words.length * 4;\n    this._process();\n    return this._hash;\n  }\n}\nfunction sha256base64(message) {\n  return new SHA256().finalize(message).toString(Base64);\n}\nfunction hash(object, options = {}) {\n  const hashed = typeof object === \"string\" ? object : objectHash(object, options);\n  return sha256base64(hashed).slice(0, 10);\n}\nconst ProductId = \"#product\";\nconst productResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Product\"\n  },\n  inheritMeta: [\n    \"description\",\n    \"image\",\n    { meta: \"title\", key: \"name\" }\n  ],\n  idPrefix: [\"url\", ProductId],\n  resolve(node, ctx) {\n    setIfEmpty(node, \"sku\", hash(node.name));\n    node.aggregateOffer = resolveRelation(node.aggregateOffer, ctx, aggregateOfferResolver);\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    return node;\n  },\n  resolveRootNode(product, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    const identity = find(IdentityId);\n    if (identity)\n      setIfEmpty(product, \"brand\", idReference(identity));\n    if (webPage)\n      setIfEmpty(product, \"mainEntityOfPage\", idReference(webPage));\n    return product;\n  }\n});\nconst answerResolver = defineSchemaOrgResolver({\n  cast(node) {\n    if (typeof node === \"string\") {\n      return {\n        text: node\n      };\n    }\n    return node;\n  },\n  defaults: {\n    \"@type\": \"Answer\"\n  }\n});\nconst questionResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Question\"\n  },\n  inheritMeta: [\n    \"inLanguage\"\n  ],\n  idPrefix: \"url\",\n  resolve(question, ctx) {\n    if (question.question) {\n      question.name = question.question;\n      delete question.question;\n    }\n    if (question.answer) {\n      question.acceptedAnswer = question.answer;\n      delete question.answer;\n    }\n    question.acceptedAnswer = resolveRelation(question.acceptedAnswer, ctx, answerResolver);\n    return question;\n  },\n  resolveRootNode(question, { find }) {\n    const webPage = find(PrimaryWebPageId);\n    if (webPage && asArray(webPage[\"@type\"]).includes(\"FAQPage\"))\n      dedupeMerge(webPage, \"mainEntity\", idReference(question));\n  }\n});\nconst RecipeId = \"#recipe\";\nconst recipeResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"Recipe\"\n  },\n  inheritMeta: [\n    { meta: \"title\", key: \"name\" },\n    \"description\",\n    \"image\",\n    \"datePublished\"\n  ],\n  idPrefix: [\"url\", RecipeId],\n  resolve(node, ctx) {\n    node.recipeInstructions = resolveRelation(node.recipeInstructions, ctx, howToStepResolver);\n    return node;\n  },\n  resolveRootNode(node, { find }) {\n    const article = find(PrimaryArticleId);\n    const webPage = find(PrimaryWebPageId);\n    if (article)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(article));\n    else if (webPage)\n      setIfEmpty(node, \"mainEntityOfPage\", idReference(webPage));\n    if (article?.author)\n      setIfEmpty(node, \"author\", article.author);\n    return node;\n  }\n});\nconst softwareAppResolver = defineSchemaOrgResolver({\n  defaults: {\n    \"@type\": \"SoftwareApplication\"\n  },\n  resolve(node, ctx) {\n    resolveDefaultType(node, \"SoftwareApplication\");\n    node.offers = resolveRelation(node.offers, ctx, offerResolver);\n    node.aggregateRating = resolveRelation(node.aggregateRating, ctx, aggregateRatingResolver);\n    node.review = resolveRelation(node.review, ctx, reviewResolver);\n    return node;\n  }\n});\nfunction loadResolver(resolver2) {\n  switch (resolver2) {\n    case \"address\":\n      return addressResolver;\n    case \"aggregateOffer\":\n      return aggregateOfferResolver;\n    case \"aggregateRating\":\n      return aggregateRatingResolver;\n    case \"article\":\n      return articleResolver;\n    case \"breadcrumb\":\n      return breadcrumbResolver;\n    case \"comment\":\n      return commentResolver;\n    case \"event\":\n      return eventResolver;\n    case \"foodEstablishment\":\n      return foodEstablishmentResolver;\n    case \"virtualLocation\":\n      return virtualLocationResolver;\n    case \"place\":\n      return placeResolver;\n    case \"howTo\":\n      return howToResolver;\n    case \"howToStep\":\n      return howToStepResolver;\n    case \"image\":\n      return imageResolver;\n    case \"localBusiness\":\n      return localBusinessResolver;\n    case \"offer\":\n      return offerResolver;\n    case \"openingHours\":\n      return openingHoursResolver;\n    case \"organization\":\n      return organizationResolver;\n    case \"person\":\n      return personResolver;\n    case \"product\":\n      return productResolver;\n    case \"question\":\n      return questionResolver;\n    case \"recipe\":\n      return recipeResolver;\n    case \"review\":\n      return reviewResolver;\n    case \"video\":\n      return videoResolver;\n    case \"webPage\":\n      return webPageResolver;\n    case \"webSite\":\n      return webSiteResolver;\n    case \"book\":\n      return bookResolver;\n    case \"course\":\n      return courseResolver;\n    case \"itemList\":\n      return itemListResolver;\n    case \"jobPosting\":\n      return jobPostingResolver;\n    case \"listItem\":\n      return listItemResolver;\n    case \"movie\":\n      return movieResolver;\n    case \"searchAction\":\n      return searchActionResolver;\n    case \"readAction\":\n      return readActionResolver;\n    case \"softwareApp\":\n      return softwareAppResolver;\n    case \"bookEdition\":\n      return bookEditionResolver;\n  }\n  return null;\n}\nconst resolver = {\n  __proto__: null,\n  loadResolver\n};\nfunction resolveMeta(meta) {\n  if (!meta.host && meta.canonicalHost)\n    meta.host = meta.canonicalHost;\n  if (!meta.tagPosition && meta.position)\n    meta.tagPosition = meta.position;\n  if (!meta.currency && meta.defaultCurrency)\n    meta.currency = meta.defaultCurrency;\n  if (!meta.inLanguage && meta.defaultLanguage)\n    meta.inLanguage = meta.defaultLanguage;\n  if (!meta.path)\n    meta.path = \"/\";\n  if (!meta.host && typeof document !== \"undefined\")\n    meta.host = document.location.host;\n  if (!meta.url && meta.canonicalUrl)\n    meta.url = meta.canonicalUrl;\n  if (meta.path !== \"/\") {\n    if (meta.trailingSlash && !hasTrailingSlash(meta.path))\n      meta.path = withTrailingSlash(meta.path);\n    else if (!meta.trailingSlash && hasTrailingSlash(meta.path))\n      meta.path = withoutTrailingSlash(meta.path);\n  }\n  meta.url = joinURL(meta.host || \"\", meta.path);\n  return {\n    ...meta,\n    host: meta.host,\n    url: meta.url,\n    currency: meta.currency,\n    image: meta.image,\n    inLanguage: meta.inLanguage,\n    title: meta.title,\n    description: meta.description,\n    datePublished: meta.datePublished,\n    dateModified: meta.dateModified\n  };\n}\nfunction resolveNode(node, ctx, resolver2) {\n  if (resolver2?.cast)\n    node = resolver2.cast(node, ctx);\n  if (resolver2?.defaults) {\n    let defaults2 = resolver2.defaults || {};\n    if (typeof defaults2 === \"function\")\n      defaults2 = defaults2(ctx);\n    node = {\n      ...defaults2,\n      ...node\n    };\n  }\n  resolver2.inheritMeta?.forEach((entry) => {\n    if (typeof entry === \"string\")\n      setIfEmpty(node, entry, ctx.meta[entry]);\n    else\n      setIfEmpty(node, entry.key, ctx.meta[entry.meta]);\n  });\n  if (resolver2?.resolve)\n    node = resolver2.resolve(node, ctx);\n  for (const k in node) {\n    const v = node[k];\n    if (typeof v === \"object\" && v?._resolver)\n      node[k] = resolveRelation(v, ctx, v._resolver);\n  }\n  stripEmptyProperties(node);\n  return node;\n}\nfunction resolveNodeId(node, ctx, resolver2, resolveAsRoot = false) {\n  if (node[\"@id\"] && node[\"@id\"].startsWith(\"http\"))\n    return node;\n  const prefix = (Array.isArray(resolver2.idPrefix) ? resolver2.idPrefix[0] : resolver2.idPrefix) || \"url\";\n  const rootId = node[\"@id\"] || (Array.isArray(resolver2.idPrefix) ? resolver2.idPrefix?.[1] : void 0);\n  if (!node[\"@id\"] && resolveAsRoot && rootId) {\n    node[\"@id\"] = prefixId(ctx.meta[prefix], rootId);\n    return node;\n  }\n  if (node[\"@id\"]?.startsWith(\"#/schema/\")) {\n    node[\"@id\"] = prefixId(ctx.meta[prefix], node[\"@id\"]);\n    return node;\n  }\n  let alias = resolver2?.alias;\n  if (!alias) {\n    const type = asArray(node[\"@type\"])?.[0] || \"\";\n    alias = type.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }\n  const hashNodeData = {};\n  Object.entries(node).forEach(([key, val]) => {\n    if (!key.startsWith(\"_\"))\n      hashNodeData[key] = val;\n  });\n  node[\"@id\"] = prefixId(ctx.meta[prefix], `#/schema/${alias}/${node[\"@id\"] || hashCode(JSON.stringify(hashNodeData))}`);\n  return node;\n}\nfunction resolveRelation(input, ctx, fallbackResolver, options = {}) {\n  if (!input)\n    return input;\n  const ids = asArray(input).map((a) => {\n    const keys = Object.keys(a).length;\n    if (keys === 1 && a[\"@id\"] || keys === 2 && a[\"@id\"] && a[\"@type\"]) {\n      return {\n        // we drop @type\n        \"@id\": ctx.find(a[\"@id\"])?.[\"@id\"] || a[\"@id\"]\n      };\n    }\n    let resolver2 = fallbackResolver;\n    if (a._resolver) {\n      resolver2 = a._resolver;\n      if (typeof resolver2 === \"string\")\n        resolver2 = loadResolver(resolver2);\n      delete a._resolver;\n    }\n    if (!resolver2)\n      return a;\n    let node = resolveNode(a, ctx, resolver2);\n    if (options.afterResolve)\n      options.afterResolve(node);\n    if (options.generateId || options.root)\n      node = resolveNodeId(node, ctx, resolver2, false);\n    if (options.root) {\n      if (resolver2.resolveRootNode)\n        resolver2.resolveRootNode(node, ctx);\n      ctx.push(node);\n      return idReference(node[\"@id\"]);\n    }\n    return node;\n  });\n  if (!options.array && ids.length === 1)\n    return ids[0];\n  return ids;\n}\nfunction isPlainObject(value) {\n  if (value === null || typeof value !== \"object\") {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(value);\n  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {\n    return false;\n  }\n  if (Symbol.iterator in value) {\n    return false;\n  }\n  if (Symbol.toStringTag in value) {\n    return Object.prototype.toString.call(value) === \"[object Module]\";\n  }\n  return true;\n}\nfunction _defu(baseObject, defaults2, namespace = \".\", merger) {\n  if (!isPlainObject(defaults2)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults2);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isPlainObject(value) && isPlainObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nfunction groupBy(array, predicate) {\n  return array.reduce((acc, value, index, array2) => {\n    const key = predicate(value, index, array2);\n    if (!acc[key])\n      acc[key] = [];\n    acc[key].push(value);\n    return acc;\n  }, {});\n}\nfunction uniqueBy(array, predicate) {\n  return Object.values(groupBy(array, predicate)).map((a) => a[a.length - 1]);\n}\nconst merge = createDefu((object, key, value) => {\n  if (Array.isArray(object[key])) {\n    object[key] = [.../* @__PURE__ */ new Set([...object[key], ...value])];\n    if (key === \"itemListElement\") {\n      object[key] = [...uniqueBy(object[key], (item) => item.position)];\n    }\n    return true;\n  }\n});\nfunction dedupeNodes(nodes) {\n  const dedupedNodes = {};\n  for (const key of nodes.keys()) {\n    const n = nodes[key];\n    const nodeKey = resolveAsGraphKey(n[\"@id\"] || hash(n));\n    if (dedupedNodes[nodeKey])\n      dedupedNodes[nodeKey] = merge(nodes[key], dedupedNodes[nodeKey]);\n    else\n      dedupedNodes[nodeKey] = nodes[key];\n  }\n  return Object.values(dedupedNodes);\n}\nfunction normaliseNodes(nodes) {\n  const sortedNodeKeys = nodes.keys();\n  const dedupedNodes = {};\n  for (const key of sortedNodeKeys) {\n    const n = nodes[key];\n    const nodeKey = resolveAsGraphKey(n[\"@id\"] || hash(n));\n    const groupedKeys = groupBy(Object.keys(n), (key2) => {\n      const val = n[key2];\n      if (key2.startsWith(\"_\"))\n        return \"ignored\";\n      if (Array.isArray(val) || typeof val === \"object\")\n        return \"relations\";\n      return \"primitives\";\n    });\n    const keys = [\n      ...(groupedKeys.primitives || []).sort(),\n      ...(groupedKeys.relations || []).sort()\n    ];\n    let newNode = {};\n    for (const key2 of keys)\n      newNode[key2] = n[key2];\n    if (dedupedNodes[nodeKey])\n      newNode = merge(newNode, dedupedNodes[nodeKey]);\n    dedupedNodes[nodeKey] = newNode;\n  }\n  return Object.values(dedupedNodes);\n}\nfunction createSchemaOrgGraph() {\n  const ctx = {\n    find(id) {\n      const key = resolveAsGraphKey(id);\n      return ctx.nodes.filter((n) => !!n[\"@id\"]).find((n) => resolveAsGraphKey(n[\"@id\"]) === key);\n    },\n    push(input) {\n      asArray(input).forEach((node) => {\n        const registeredNode = node;\n        ctx.nodes.push(registeredNode);\n      });\n    },\n    resolveGraph(meta) {\n      ctx.meta = resolveMeta({ ...meta });\n      ctx.nodes.forEach((node, key) => {\n        const resolver2 = node._resolver;\n        if (resolver2) {\n          node = resolveNode(node, ctx, resolver2);\n          node = resolveNodeId(node, ctx, resolver2, true);\n        }\n        ctx.nodes[key] = node;\n      });\n      ctx.nodes = dedupeNodes(ctx.nodes);\n      ctx.nodes.forEach((node) => {\n        if (node.image && typeof node.image === \"string\") {\n          node.image = resolveRelation(node.image, ctx, imageResolver, {\n            root: true\n          });\n        }\n        if (node._resolver?.resolveRootNode)\n          node._resolver.resolveRootNode(node, ctx);\n        delete node._resolver;\n      });\n      return normaliseNodes(ctx.nodes);\n    },\n    nodes: [],\n    meta: {}\n  };\n  return ctx;\n}\nfunction UnheadSchemaOrg(options) {\n  return SchemaOrgUnheadPlugin({}, () => ({}), options);\n}\nfunction PluginSchemaOrg(options) {\n  const fallback = () => ({});\n  return SchemaOrgUnheadPlugin({}, options?.resolveMeta || fallback, options);\n}\nfunction SchemaOrgUnheadPlugin(config, meta, options) {\n  config = resolveMeta({ ...config });\n  let graph;\n  let resolvedMeta = {};\n  return defineHeadPlugin((head) => ({\n    key: \"schema-org\",\n    hooks: {\n      \"entries:resolve\": function() {\n        graph = createSchemaOrgGraph();\n      },\n      \"tag:normalise\": async function({ tag }) {\n        if (tag.key === \"schema-org-graph\") {\n          const { loadResolver: loadResolver2 } = await Promise.resolve().then(function() {\n            return resolver;\n          });\n          const nodes = await tag.props.nodes;\n          for (const node of Array.isArray(nodes) ? nodes : [nodes]) {\n            const newNode = {\n              ...node,\n              _resolver: loadResolver2(await node._resolver)\n            };\n            graph.push(newNode);\n          }\n          tag.tagPosition = tag.tagPosition || config.tagPosition === \"head\" ? \"head\" : \"bodyClose\";\n        }\n        if (tag.tag === \"htmlAttrs\" && tag.props.lang) {\n          resolvedMeta.inLanguage = tag.props.lang;\n        } else if (tag.tag === \"title\") {\n          resolvedMeta.title = tag.textContent;\n        } else if (tag.tag === \"meta\" && tag.props.name === \"description\") {\n          resolvedMeta.description = tag.props.content;\n        } else if (tag.tag === \"link\" && tag.props.rel === \"canonical\") {\n          resolvedMeta.url = tag.props.href;\n          if (resolvedMeta.url && !resolvedMeta.host) {\n            try {\n              resolvedMeta.host = new URL(resolvedMeta.url).origin;\n            } catch {\n            }\n          }\n        } else if (tag.tag === \"meta\" && tag.props.property === \"og:image\") {\n          resolvedMeta.image = tag.props.content;\n        } else if (tag.tag === \"templateParams\" && tag.props.schemaOrg) {\n          resolvedMeta = {\n            ...resolvedMeta,\n            // @ts-expect-error untyped\n            ...tag.props.schemaOrg\n          };\n          delete tag.props.schemaOrg;\n        }\n      },\n      \"tags:resolve\": async function(ctx) {\n        for (const tag of ctx.tags) {\n          if (tag.tag === \"script\" && tag.key === \"schema-org-graph\") {\n            const minify = options?.minify || true;\n            tag.innerHTML = JSON.stringify({\n              \"@context\": \"https://schema.org\",\n              \"@graph\": graph.resolveGraph({ ...await meta?.() || {}, ...config, ...resolvedMeta })\n            }, (_, value) => {\n              if (typeof value !== \"object\")\n                return processTemplateParams(value, head._templateParams, head._separator);\n              return value;\n            }, minify ? 0 : 2);\n            delete tag.props.nodes;\n            return;\n          }\n        }\n      }\n    }\n  }));\n}\nexport { webSiteResolver as $, itemListResolver as A, imageResolver as B, jobPostingResolver as C, listItemResolver as D, localBusinessResolver as E, movieResolver as F, offerResolver as G, HowToId as H, openingHoursResolver as I, organizationResolver as J, personResolver as K, addressResolver as L, ProductId as M, productResolver as N, questionResolver as O, PrimaryArticleId as P, ratingResolver as Q, RecipeId as R, recipeResolver as S, softwareAppResolver as T, UnheadSchemaOrg as U, reviewResolver as V, videoResolver as W, PrimaryWebPageId as X, webPageResolver as Y, readActionResolver as Z, PrimaryWebSiteId as _, dedupeNodes as a, searchActionResolver as a0, PluginSchemaOrg as a1, SchemaOrgUnheadPlugin as a2, resolveNode as b, createSchemaOrgGraph as c, defineSchemaOrgResolver as d, resolveNodeId as e, resolveRelation as f, aggregateOfferResolver as g, aggregateRatingResolver as h, articleResolver as i, bookEditionResolver as j, PrimaryBookId as k, bookResolver as l, PrimaryBreadcrumbId as m, normaliseNodes as n, breadcrumbResolver as o, commentResolver as p, courseResolver as q, resolveMeta as r, PrimaryEventId as s, eventResolver as t, placeResolver as u, virtualLocationResolver as v, foodEstablishmentResolver as w, howToResolver as x, howToStepResolver as y, howToStepDirectionResolver as z };\n",
      "start": 1708316410360,
      "end": 1708316410454,
      "order": "normal",
      "sourcemaps": null
    },
    {
      "name": "vite:css-post",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "unhead:use-seo-meta-transform",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1708316410454,
      "end": 1708316410454,
      "order": "normal"
    }
  ]
}
